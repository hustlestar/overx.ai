---
title: "Дизайн ИИ-Агентов: Техническая Структура"
excerpt: "Структура разработки производственных ИИ-агентов, охватывающая основные инженерные задачи через семь технических вопросов. Основана на практическом опыте разработки."
coverImage: "/images/posts/create-ai-agent-hero.png"
images:
  - url: "/images/posts/create-ai-agent-hero.png"
    alt:
      en: "Technical AI agent architecture planning with data flows and system design"
      es: "Planificación técnica de arquitectura de agentes de IA con flujos de datos y diseño de sistemas"
      ru: "Техническое планирование архитектуры ИИ-агента с потоками данных и дизайном системы"
    width: 1344
    height: 768
    type: "hero"
  - url: "/images/posts/ai-agent-7-questions-infographic.png"
    alt:
      en: "Technical framework: 7 engineering questions for production AI agent design"
      es: "Marco técnico: 7 preguntas de ingeniería para diseño de agentes de IA en producción"
      ru: "Техническая структура: 7 инженерных вопросов для разработки производственных ИИ-агентов"
    width: 1312
    height: 736
    type: "featured"
  - url: "/images/posts/ai-agent-decision-flow.png"
    alt:
      en: "Layered decision architecture with validation checkpoints and error handling"
      es: "Arquitectura de decisiones en capas con puntos de validación y manejo de errores"
      ru: "Многоуровневая архитектура принятия решений с контрольными точками и обработкой ошибок"
    width: 1152
    height: 896
    type: "content"
  - url: "/images/posts/ai-agent-comparison.png"
    alt:
      en: "Architecture comparison: experimental agent vs production-grade agent with failure handling"
      es: "Comparación de arquitectura: agente experimental vs agente de producción con manejo de fallos"
      ru: "Сравнение архитектуры: экспериментальный агент против производственного агента с обработкой сбоев"
    width: 1536
    height: 640
    type: "content"
date: "2025-11-03T09:00:00.000Z"
lastModified: "2025-11-03T09:00:00.000Z"
author: "jack-ma"
category: "ai-insights"
tags: ["ai-agents", "agent-architecture", "production-ai", "langchain", "langgraph", "llamaindex", "mcp", "ai-engineering"]
featured: true
seo:
  metaTitle: "Дизайн ИИ-Агентов: Техническая Структура для Производственных Систем | OverX AI"
  metaDescription: "Структура разработки производственных ИИ-агентов, охватывающая архитектуру данных, интеграцию инструментов, оценку и обработку сбоев. LangChain vs LangGraph vs LlamaIndex."
  metaKeywords: ["архитектура ИИ-агентов", "производственные ИИ-агенты", "LangChain vs LangGraph", "LlamaIndex", "протокол MCP", "оценка ИИ-агентов", "обработка сбоев агентов", "архитектура RAG"]
  canonicalUrl: "https://blog.overx.ai/post/create-ai-agent-questions"
---

## Введение

Большинство ИИ-агентов терпят неудачу в производстве не из-за плохой реализации, а из-за недостаточного архитектурного планирования. Это руководство представляет техническую структуру для проектирования производственных ИИ-агентов, основанную на практическом опыте разработки.

Структура состоит из семи технических вопросов, которые рассматривают основные инженерные задачи в разработке агентов. Каждый вопрос нацелен на конкретный режим отказа, обычно наблюдаемый в производственных системах.

---

![Техническая Структура](/images/posts/ai-agent-7-questions-infographic.png)

## Вопрос 1: Какие данные требуются агенту и как к ним будет осуществляться доступ?

Архитектура данных для ИИ-агентов принципиально отличается от традиционных приложений. Агентам необходимо извлекать, рассуждать над данными и иногда изменять их динамически в зависимости от требований задачи.

### Критические соображения:

**Решения по архитектуре хранения:**

**Когда использовать векторные базы данных:**
- Агенту требуется семантический поиск по неструктурированным данным
- Поиск основан на значении, а не на точных совпадениях
- Коллекции документов, базы знаний, история разговоров
- Примеры: Pinecone, Weaviate, Qdrant, Chroma
- Стоимость: Хранение + генерация эмбеддингов + стоимость запросов

**Когда использовать RDBMS:**
- Структурированные данные с отношениями
- Требуется транзакционная целостность
- Необходима сложная фильтрация и объединения
- Примеры: Записи клиентов, история заказов, инвентарь
- Агент запрашивает через генерацию SQL или ORM

**Когда использовать графовые базы данных:**
- Отношения между сущностями центральны для рассуждений
- Мультихоп-запросы через связи
- Графы знаний, организационные структуры
- Примеры: Neo4j, Amazon Neptune
- Агент пересекает отношения для контекста

**Когда использовать хранилища ключ-значение:**
- Состояние сессии и память разговора
- Быстрое чтение/запись для состояния агента
- Кэширование промежуточных результатов
- Примеры: Redis, DynamoDB
- Низкая задержка критична для циклов агента

**Гибридные архитектуры:**

Большинство производственных агентов используют несколько типов хранилища:

Пример: Агент службы поддержки клиентов
- Vector DB: Документация продуктов, прошлые тикеты (семантический поиск)
- RDBMS: Данные клиентов, история заказов (структурированные запросы)
- Redis: Состояние разговора, недавний контекст (быстрый доступ)
- S3: Вложения, изображения, файлы (хранилище blob)

**Паттерны доступа к данным, специфичные для агентов:**

**Retrieval-augmented generation (RAG):**
- Агент запрашивает vector DB для релевантного контекста
- Контекст вставляется в промпт LLM
- Проблема: Баланс между размером контекста и релевантностью
- Стратегия: Многоэтапный поиск (широкий → узкий)

**Динамическая выборка данных:**
- Агент решает, какие данные выбирать на основе задачи
- Вызов инструментов для доступа к различным источникам данных
- Проблема: Задержка накапливается при множественных вызовах
- Стратегия: Параллельная выборка, когда зависимости позволяют

**Управление состоянием:**
- Краткосрочная память: Текущий разговор (в памяти или Redis)
- Долгосрочная память: Предпочтения пользователя, история (RDBMS)
- Проблема: Что запомнить, что забыть
- Стратегия: Суммаризация для старого контекста, оценка важности

**Данные в реальном времени vs индексированные данные:**
- Индексированные: Предварительно встроенные документы в vector DB (быстро, потенциально устарело)
- Реальное время: Выборка и встраивание по требованию (медленно, всегда свежие)
- Проблема: Когда устаревание приемлемо?
- Стратегия: Гибридный подход — индексировать статический контент, реальное время для динамического

**Стратегии свежести данных:**

**Для векторных баз данных:**
- Инкрементные обновления: Переэмбеддинг только измененных документов
- Запланированные пересборки: Полная переиндексация еженедельно/ежемесячно
- Версионирование: Поддержка нескольких версий индекса
- Проблема: Эмбеддинги не обновляются автоматически при изменении источника

**Для RDBMS:**
- Кэш с TTL для часто запрашиваемых данных
- Событийная инвалидация для критических обновлений
- Реплики для чтения для масштабирования агентов с интенсивным чтением
- Проблема: Задержка репликации в распределенных системах

**Проблемы качества данных, специфичные для агентов:**

**Качество эмбеддингов:**
- Размер чанка влияет на качество поиска (слишком маленький: нет контекста, слишком большой: шум)
- Модель эмбеддинга имеет значение (OpenAI vs open source vs fine-tuned)
- Фильтрация метаданных уменьшает пространство поиска, но может упустить релевантные результаты
- Тестирование: Набор тестовых запросов и измерение точности/полноты поиска

**Управление окном контекста:**
- Агент должен решить, какие данные поместятся в ограниченный контекст
- Приоритизация: Наиболее релевантные? Самые свежие? Наивысшая уверенность?
- Стратегия усечения: Удалить середину? Суммаризировать? Разделить запрос?
- Тестирование: Проверить, что критическая информация не теряется при усечении

**Согласованность множественных источников:**
- Агент может получить конфликтующие данные из разных источников
- Стратегия: Ранжирование приоритета источников, правила разрешения конфликтов
- Пример: API реального времени конфликтует с кэшированными данными — кому доверять?
- Тестирование: Внедрить конфликты и проверить, что агент обрабатывает их корректно

### Технический чеклист:

- [ ] Типы хранилища обоснованы для каждой категории данных (vector/RDBMS/graph/KV)
- [ ] Стратегия эмбеддинга определена (модель, размер чанка, частота обновления)
- [ ] Стратегия управления окном контекста документирована
- [ ] Правила согласованности данных из множественных источников определены
- [ ] Стратегия памяти: что сохраняется vs что эфемерно
- [ ] Задержка доступа к данным измерена для каждого источника
- [ ] Анализ стоимости: хранение + эмбеддинги + запросы при ожидаемой нагрузке
- [ ] Метрики качества поиска: точность/полнота на тестовых запросах
- [ ] Стратегия кэша: что кэшировать, TTL, триггеры инвалидации
- [ ] Резервный вариант при недоступности основных данных: деградация vs сбой

---

## Вопрос 2: Какой уровень архитектурной сложности подходит?

Не каждая задача требует фреймворка ИИ-агента. Выбор правильной архитектуры предотвращает ненужную сложность и снижает операционные затраты.

### Матрица решений:

**Детерминированная логика (if-else):**
- Все входные данные структурированы
- Вывод полностью детерминирован
- Набор правил управляем (<50 правил)
- Пример: Маршрутизация email по домену отправителя

**Автоматизация рабочих процессов (n8n, Zapier, Airflow):**
- Последовательные вызовы API
- Рассуждение не требуется
- Переходы состояний предопределены
- Пример: "Новая регистрация → Добавить в CRM → Отправить приветственное письмо"

**Когда n8n технически достаточен, но не оптимален:**

n8n может обрабатывать многие рабочие процессы, включающие оркестрацию API и простую условную логику. Однако рассмотрите эти ограничения:

*Минусы n8n для задач, похожих на агенты:*
- Нет нативного рассуждения LLM или динамического принятия решений
- Ограниченные стратегии восстановления после ошибок и повторных попыток
- Сложно версионировать изменения рабочих процессов
- Сложно реализовать сложную логику валидации
- Нет встроенных фреймворков оценки или тестирования
- Масштабирование требует управления несколькими экземплярами рабочих процессов
- Отладка сложных потоков зависит от GUI
- Ограниченная наблюдаемость для трассировки решений
- Сложно реализовать стратегии постепенного внедрения
- Сложно реализовать A/B тестирование изменений логики
- Детальные метрики производительности по точкам решений

n8n хорошо работает для простой автоматизации, но становится проблематичным, когда задачи требуют:
- Принятия решений в зависимости от контекста
- Динамического выбора инструментов на основе промежуточных результатов
- Сложной обработки ошибок с откатом
- Изощренных проверок валидации и безопасности
- A/B тестирования изменений логики
- Детальных метрик производительности по точкам решений

**LLM в конвейере (один вызов модели):**
- Требуется понимание естественного языка
- Задача классификации или генерации
- Нет многошагового рассуждения
- Пример: Анализ тональности, категоризация контента

**Фреймворк агентов - LangChain:**
- Необходимо базовое связывание инструментов
- Последовательные рабочие процессы рассуждения
- Более простые паттерны агентов (ReAct, разговорные)
- Приоритет быстрого прототипирования
- Пример: Бот поддержки клиентов с поиском в базе знаний

**Фреймворк агентов - LlamaIndex:**
- Поиск и извлечение данных центральны для задачи
- Рабочие процессы RAG (Retrieval-Augmented Generation)
- Работа в основном с документами и базами знаний
- Необходимо понимание и маршрутизация запросов
- Событийные рабочие процессы приема данных
- Пример: Система Q&A по документам, исследовательский ассистент

**Фреймворк агентов - LangGraph:**
- Сложное многошаговое рассуждение с условными путями
- Требуются циклические графы и откат
- Управление состоянием через множественные вызовы агента
- Детальный контроль над потоком выполнения
- Пример: Исследовательская задача, требующая итерации и уточнения

**Мультиагентная система (CrewAI, AutoGen):**
- Необходима параллелизация задач
- Ролевая специализация улучшает результаты
- Требуется сложная координация
- Пример: Конкурентный анализ с агентами исследования, анализа и отчетности

### LlamaIndex vs LangGraph: Техническое Сравнение

**Сильные стороны LlamaIndex:**

**Специализация на приеме данных и рабочих процессах поиска**
- Встроенные коннекторы для 100+ источников данных (базы данных, API, файловые системы)
- Оптимизированные конвейеры приема эффективно обрабатывают большие коллекции документов
- Автоматические стратегии разбиения на части протестированы в масштабе

**Событийно-ориентированная архитектура**
- Движок рабочих процессов для построения сложных конвейеров поиска
- Событийный подход позволяет реактивное поведение агентов
- Более быстрая разработка для приложений с интенсивным поиском
- Пример: Новый документ → триггер эмбеддинга → обновление индекса → уведомление агента
- Это значительно уменьшает шаблонный код по сравнению с ручным управлением состоянием LangGraph

**Оптимизированные стратегии индексирования**
- Векторные индексы, древовидные индексы, ключевые индексы, графы знаний
- Композируемые индексы для иерархического поиска
- Автоматическая маршрутизация запросов через множественные индексы

**Движки запросов с изощренным поиском**
- Декомпозиция подвопросов для сложных запросов
- Многодокументный поиск и синтез
- Поиск с фильтрацией и метаданными

**Возможности агентов вторичны по отношению к поиску**

Это означает: Агенты LlamaIndex могут использовать инструменты и принимать решения, но фреймворк оптимизирован для рабочего процесса поиска, а не для общей оркестрации агентов. Если основная задача вашего агента — "найти релевантную информацию и ответить на вопросы", LlamaIndex превосходен. Если вашему агенту нужны сложные деревья решений, условная логика или многошаговое планирование, где поиск — это лишь один инструмент среди многих, LlamaIndex становится неудобным.

Пример: Создание агента поддержки клиентов
- LlamaIndex блистает: 80% работы — поиск документации
- LlamaIndex испытывает трудности: Агенту нужно проверить инвентарь, обработать возвраты, обновить тикеты — поиск составляет 20% задачи

**Более категоричная архитектура**

Это означает: LlamaIndex делает сильные предположения о том, как вы структурируете данные и рабочие процессы поиска. Он предоставляет четкие паттерны (типы индексов, движки запросов, ретриверы), но отклонение от этих паттернов требует борьбы с фреймворком.

Пример: Вы хотите кастомную логику поиска
- LlamaIndex: Должен работать в рамках их абстракции Retriever, переопределять конкретные методы
- LangGraph: Построить любую логику поиска как узел в графе

Это хорошо, когда мнения совпадают с вашим случаем использования (более быстрая разработка), плохо, когда нет (трение фреймворка).

**Ограничения LlamaIndex:**

**Меньше гибкости для не-RAG рабочих процессов**
- Если агенту нужно оркестрировать API, базы данных и внешние инструменты, где поиск вторичен, LlamaIndex добавляет накладные расходы
- Фреймворк предполагает, что поиск центральный; другие задачи кажутся приставленными

**Возможности агентов кажутся вторичными**
- ReAct агенты существуют, но менее зрелы, чем функции поиска
- Мультиагентная оркестрация возможна, но не является сильной стороной фреймворка
- Вызов инструментов работает, но не так естественен, как в LangGraph

**Сильные стороны LangGraph:**

**Полный контроль над потоком выполнения агента**
- Определите точно, как агент перемещается между состояниями
- Условное ветвление, циклы, параллельное выполнение — все явно
- Нет скрытой логики; вы видите весь путь выполнения

**Явное управление состоянием с StateGraph**
- Состояние агента — это типизированный объект, который вы определяете
- Каждый узел явно читает и изменяет состояние
- Проще отлаживать: проверять состояние в любой точке
- Проще тестировать: вставить состояние и проверить поведение узла

**Поддержка циклических рабочих процессов и условного ветвления**
- Агент может вернуться к предыдущим шагам на основе результатов
- Существенно для исследовательских задач, итеративного уточнения, восстановления после ошибок
- Пример: Генерация черновика → Критика → Ревизия → Снова критика → Финализация

**Лучше для сложного многошагового рассуждения**
- Когда агенту нужно планировать, выполнять, оценивать, переplanировать
- Когда различные пути через логику на основе промежуточных результатов
- Когда необходим откат или попытка альтернативных подходов

**Встроенное сохранение контрольных точек и воспроизведение**
- Сохранение состояния агента в любой точке
- Возобновление с контрольной точки после сбоя
- Воспроизведение выполнения для отладки
- Критично для долгосрочных задач агента

**Ограничения LangGraph:**

**Больше шаблонного кода для простых RAG рабочих процессов**
- Необходимо явно определить узлы поиска, обновления состояния, ребра
- LlamaIndex предоставляет это из коробки
- Простое "извлечь и ответить" требует больше кода

**Менее оптимизирован для чистого поиска/извлечения**
- Нет встроенных типов индексов или стратегий поиска
- Вы интегрируетесь с vector DB вручную
- Качество поиска зависит от вашей реализации

**Нет встроенных событийных паттернов**
- Вы строите реактивное поведение вручную
- Больше кода для рабочих процессов, запускаемых изменениями данных
- Событийная система LlamaIndex обрабатывает это естественно

### Критерии решения:

**Выберите LlamaIndex когда:**
- Основная задача — поиск документов и Q&A
- Вам нужно изощренное понимание и декомпозиция запросов
- RAG — основной паттерн (80%+ работы агента)
- Вы хотите оптимизированные стратегии индексирования из коробки
- Вам нужны событийные процессы приема и обновления данных
- Приоритет — быстрая разработка приложений с интенсивным поиском
- Пример: Чатбот документации, исследовательский ассистент, Q&A базы знаний

**Выберите LangGraph когда:**
- Сложные деревья решений с условным ветвлением
- Многошаговое рассуждение, требующее управления состоянием
- Циклические рабочие процессы, где агент возвращается к предыдущим шагам
- Поиск — один инструмент среди многих (не основной паттерн)
- Вам нужен детальный контроль и возможности отладки
- Долгосрочные задачи, требующие сохранения контрольных точек
- Пример: Исследовательский аналитик, автоматизация задач, оркестрация рабочих процессов

**Выберите LangChain когда:**
- Простые последовательные цепочки достаточны
- Приоритет — быстрое прототипирование
- Стандартные паттерны (ReAct, разговорные) соответствуют требованиям
- Вам не нужно сложное управление состоянием или циклы

---

## Вопрос 2.5: Как агент должен получать доступ к внешним системам — прямые вызовы API, инструменты или MCP?

Это часто упускаемое из виду решение, которое значительно влияет на архитектуру агента, поддерживаемость и сложность отладки.

### Три подхода:

**1. Прямые вызовы API в коде агента**
**2. Абстракции вызова инструментов/функций**
**3. Model Context Protocol (MCP)**

Вызов инструментов и MCP — связанные концепции на спектре абстракции. Вызов инструментов дает LLM доступ к функциям; MCP стандартизирует, как эти функции выставляются и обнаруживаются. Понимание, когда каждый подход уместен, предотвращает переинженерию.

### Когда использовать прямые вызовы API:

**Подходящие сценарии:**
- Агенту нужен явный контроль над обработкой запросов/ответов
- Требуется кастомная логика обработки ошибок для каждой конечной точки
- Сложные потоки аутентификации (OAuth, обновление токенов)
- Трансформация запросов/ответов не тривиальна
- Лимитирование скорости API требует изощренной логики
- Вам нужны стратегии пакетирования запросов или кэширования

**Пример: Прямой контроль API**

Рассмотрим агента поддержки клиентов, которому нужно проверить статус заказа:

```
Подход с прямым API:
1. Агент извлекает ID клиента из контекста
2. Ваш код явно вызывает OrderService.get_order(customer_id)
3. Ваш код обрабатывает таймаут, повторную попытку, лимитирование скорости
4. Ваш код трансформирует ответ в контекст для LLM
5. Ваш код валидирует ответ перед передачей агенту
6. Полная видимость происходящего
```

**Преимущества:**
- Полный контроль над потоком выполнения
- Легко отлаживать: ставить точки останова, проверять запросы/ответы
- Кастомное кэширование, пакетирование, размыкатели цепей
- Типобезопасность с клиентскими библиотеками
- Нет уровня абстракции, скрывающего проблемы
- Четкое распространение ошибок

**Недостатки:**
- Больше шаблонного кода
- Агент не "решает", когда вызывать — вы оркестрируете
- Меньше гибкости, если агенту нужно динамически обнаруживать инструменты

**Когда это оптимально:**
- У вас 3-10 хорошо определенных точек интеграции
- API требуют сложной обработки ошибок
- Вам нужно предсказуемое, отлаживаемое выполнение
- Критична оптимизация производительности (кэширование, пакетирование)
- Безопасность/соответствие требует явного контроля

### Когда использовать вызов инструментов/функций:

**Подходящие сценарии:**
- Агенту нужно решать, какой инструмент использовать на основе контекста
- Динамический выбор инструмента из большого набора (10+ инструментов)
- Вы хотите, чтобы LLM рассуждал о том, какой API вызвать
- Инструменты относительно независимы (без сложной оркестрации)

**Как это работает:**
- Вы определяете схемы инструментов (имя, описание, параметры)
- LLM получает описания инструментов в каждом запросе
- LLM решает, какой инструмент вызвать и с какими параметрами
- Ваш код выполняет инструмент и возвращает результаты
- LLM обрабатывает результаты и решает следующее действие

**Преимущества:**
- Автономия агента: LLM выбирает подходящий инструмент
- Легче добавлять новые инструменты без изменения логики оркестрации
- Естественный язык в структурированные вызовы API
- Агент может связывать инструменты на основе промежуточных результатов

**Недостатки:**
- LLM может галлюцинировать параметры инструментов
- Отладка сложнее: Почему LLM выбрал этот инструмент?
- Стоимость токенов: Схемы инструментов отправляются с каждым запросом
- Меньше контроля над порядком выполнения
- Обработка ошибок передается через интерпретацию LLM

**Когда это оптимально:**
- Агенту нужно выбирать из множества возможных действий
- Выбор инструмента требует рассуждения над контекстом
- Вы хотите, чтобы агент обнаруживал оптимальные последовательности инструментов
- Инструменты в основном независимые операции
- Вы можете терпеть случайные ошибки выбора инструментов

### Когда использовать MCP (Model Context Protocol):

**Что такое MCP на самом деле:**
- Стандартизированный протокол для выставления источников данных и инструментов LLM
- Серверные ресурсы, которые агенты могут обнаруживать и использовать
- Абстрагирует реализации инструментов от кода агента
- Способствует повторному использованию через различных агентов/приложения
- Думайте об этом как: вызов инструментов + стандартизация + удаленное выполнение + обнаруживаемость

**Отношение между вызовом инструментов и MCP:**

Вызов инструментов — это механизм; MCP — уровень стандартизации:
- Вызов инструментов: LLM вызывает функции, которые вы определили
- MCP: Стандартизированный способ выставлять эти функции, запускать их на отдельных серверах, делиться ими между агентами

MCP = Вызов инструментов + Удаленное выполнение + Стандартизированный протокол + Обнаружение

**Подходящие сценарии:**
- Множественным агентам нужны одни и те же интеграции инструментов
- Вы хотите централизовать управление инструментами
- Сторонние поставщики инструментов выставляют MCP серверы
- Вы строите платформу, где пользователи добавляют кастомные инструменты
- Реализации инструментов часто меняются, агенты не должны

**Пример архитектуры:**
```
Без MCP (вызов инструментов):
Код Агента 1 → определяет инструмент Slack → выполняет локально
Код Агента 2 → определяет тот же инструмент Slack → выполняет локально (дублировано)
Код Агента 3 → определяет тот же инструмент Slack → выполняет локально (дублировано)

С MCP:
Агент 1 → MCP Клиент → (сеть) → MCP Slack Сервер
Агент 2 → MCP Клиент → (сеть) → MCP Slack Сервер
Агент 3 → MCP Клиент → (сеть) → MCP Slack Сервер
```

**Преимущества:**
- Повторное использование: Написать интеграцию инструмента один раз, использовать в множественных агентах
- Управление: Централизованный контроль над доступом к инструментам и разрешениями
- Обнаруживаемость: Агенты могут запрашивать доступные инструменты динамически
- Безопасность: Инструменты запускаются на отдельных серверах с собственной аутентификацией
- Обновления: Изменить реализацию инструмента без касания агентов
- Песочница: Инструменты, предоставленные пользователями, запускаются изолированно от кода агента

**Недостатки:**
- Дополнительная сложность инфраструктуры (серверы, сеть, развертывание)
- Сетевые вызовы добавляют задержку (дополнительный круговой путь на выполнение инструмента)
- Сложнее отлаживать: выполнение инструмента происходит удаленно
- Еще один уровень абстракции для понимания
- Ограниченная экосистема (новый стандарт, мало доступных серверов)
- Управление версиями через MCP серверы и клиенты
- Операционные накладные расходы: мониторинг, масштабирование MCP серверов

### Спектр абстракции:

```
Прямые вызовы API → Вызов инструментов → MCP
      ↓                ↓           ↓
Наибольший контроль  Умеренный   Наименьший контроль
Наименьшее повторное использование  Некоторое повторное использование  Наибольшее повторное использование
Легче всего отлаживать  Сложнее  Сложнее всего
Без накладных расходов  Стоимость токенов  Стоимость токенов + сети
```

### Когда MCP действительно ценен (а не просто хайп):

**Мультиагентные платформы:**
- Вы строите платформу с 10+ агентами
- Разные команды создают разных агентов
- Инструментам нужно согласованное поведение через агентов
- Пример: Корпоративная AI платформа с общими интеграциями

**Расширяемые пользователями системы:**
- Пользователи могут добавлять кастомные инструменты к своим агентам
- Вы не хотите, чтобы пользовательский код запускался в вашем агенте
- MCP серверы обеспечивают песочницу
- Пример: Маркетплейс агентов со сторонними инструментами

**Часто меняющиеся реализации инструментов:**
- API инструментов часто меняются
- Вы не хотите переразвертывать всех агентов
- Обновить MCP сервер, агенты автоматически используют новую версию

**Межорганизационное совместное использование инструментов:**
- Внешние партнеры выставляют MCP серверы
- Вы потребляете их инструменты без реализации
- Пример: Salesforce, Slack, GitHub выставляют MCP серверы (будущее видение)

**Управление и соответствие:**
- Нужны централизованные логи аудита использования инструментов
- Разным агентам нужны разные разрешения
- MCP сервер централизованно обеспечивает контроль доступа

### Когда MCP — хайп/преждевременно:

**Одноагентные приложения:**
- Вы строите одного агента для конкретного случая использования
- Прямые вызовы API или вызов инструментов проще
- MCP добавляет сложность без выгоды
- Накладные расходы не оправданы выигрышем в повторном использовании

**Малое количество стабильных интеграций:**
- 3-5 API, которые редко меняются
- Прямая реализация яснее и быстрее
- Абстракция MCP скрывает происходящее
- Вызов инструментов обеспечивает достаточную абстракцию

**Критичные к производительности приложения:**
- Дополнительный сетевой скачок неприемлем
- Нужны времена отклика менее 100мс
- Требуются прямые вызовы API с кэшированием
- Каждый вызов MCP добавляет 50-200мс задержки

**Ранняя разработка/MVP:**
- Требования все еще быстро меняются
- Стандартизация MCP замедляет итерацию
- Лучше сначала жестко кодировать, абстрагировать позже
- Определения инструментов часто меняются во время прототипирования

**Ограниченная экосистема:**
- Сегодня существует мало сторонних MCP серверов
- Вы будете реализовывать большинство серверов самостоятельно
- Незрелость экосистемы означает меньшую ценность от стандартизации

### Структура решения:

**Начните с прямых вызовов API когда:**
- Один агент или малый проект
- <5 внешних интеграций
- Нужна видимость отладки
- Производительность имеет значение (<200мс общая задержка)
- Требования неясны (быстрая итерация)
- Необходима сложная обработка ошибок

**Переходите к вызову инструментов когда:**
- Агенту нужно выбирать из множественных действий (10+ инструментов)
- Выбор инструмента требует рассуждения
- Часто добавляете инструменты
- Инструменты относительно независимы
- Приемлемая задержка: 500мс-2с

**Рассматривайте MCP только когда:**
- Строите мультиагентную платформу (5+ агентов)
- Множественные команды/агенты делятся инструментами
- Расширяемая пользователями система (пользователи добавляют кастомные инструменты)
- Требуется управление инструментами (разрешения, логи аудита)
- Обновления инструментов должны быть независимы от развертывания агентов
- Материализуется поддержка экосистемы (все еще рано в 2025)
- Приемлемая задержка: 1с-5с

### Гибридный подход (рекомендован для большинства):

**Общий паттерн:**
```
Основные интеграции (3-5 критических API):
→ Прямые вызовы API с явным контролем
→ Кастомная обработка ошибок, кэширование, оптимизация
→ Критично к производительности, нужна задержка <100мс

Вторичные инструменты (10-20 опциональных действий):
→ Вызов инструментов/функций для гибкости
→ Агент решает, когда использовать
→ Приемлемая задержка: 500мс-1с

Будущее: Интеграция MCP когда:
→ Экосистема созревает
→ Третьи стороны выставляют серверы
→ Возникают мультиагентные потребности
→ Можно терпеть дополнительную задержку
```

### Реальный пример:

**Агент поддержки клиентов:**

**Прямые вызовы API:**
- База данных клиентов (нужно кэширование, сложные запросы, <50мс)
- Система заказов (транзакционная, требует повторных попыток, <100мс)
- Проверка инвентаря (критична к производительности, нужно пакетирование, <100мс)

**Вызов инструментов:**
- Поиск базы знаний (LLM выбирает, когда искать)
- Создание тикета поддержки (агент решает приоритет)
- Отправка email уведомления (агент составляет контент)
- Проверка статуса доставки (опциональный инструмент)
- Обработка запроса на возврат (агент оценивает приемлемость)
- Эскалация к человеку (агент определяет, когда необходимо)

**Не используется MCP (пока):**
- Только один агент использует эти интеграции
- Инструменты стабильны, редко меняются
- Нужна видимость отладки
- Требования производительности (<500мс) несовместимы с накладными расходами MCP
- MCP добавляет сложность без текущей выгоды

**Будущее рассмотрение MCP:**
- Когда строится второй агент (продажи, маркетинг), которому нужны те же инструменты
- Когда внешние партнеры хотят интегрироваться (выставить наши инструменты их агентам)
- Когда нетехнические пользователи нуждаются в добавлении кастомных инструментов
- Когда требования управления требуют централизованного контроля
- Когда экосистема созрела с доступными серверами

### Распространенные ошибки:

**Переинженерия с MCP:**
- Использование MCP для одного агента с 3 инструментами
- Добавление сетевого уровня без выигрыша в повторном использовании
- Сложность превышает выгоды

**Недостаточная абстракция с прямыми вызовами:**
- 20+ прямых интеграций API в коде агента
- Копирование-вставка реализаций инструментов через агентов
- Следовало бы использовать вызов инструментов или MCP

**Неправильная абстракция инструментов:**
- Использование вызова инструментов для 3 простых API (просто используйте прямые вызовы)
- Сложная оркестрация через вызов инструментов (используйте прямой контроль)
- LLM выбирает инструменты, которые нуждаются в конкретном порядке (используйте прямую оркестрацию)

### Текущая рекомендация (2025):

**По умолчанию используйте прямые вызовы API для <5 интеграций, вызов инструментов для 5-15 интеграций.**

MCP перспективен, но незрел. Большинству проектов абстракция пока не нужна. Переоцените MCP когда:
- Вы строите третьего агента с перекрывающимися инструментами
- Экосистема MCP серверов значительно выросла
- Ваш случай использования специально нуждается в управлении/песочнице инструментов
- Вы строите платформу, где пользователи добавляют инструменты
- Множественным командам нужна общая инфраструктура инструментов

Не используйте MCP потому что он новый и захватывающий. Используйте его, когда архитектурные выгоды (повторное использование, управление, песочница) явно превышают стоимость сложности (инфраструктура, задержка, сложность отладки).

---

![Поток Решений](/images/posts/ai-agent-decision-flow.png)

## Вопрос 3: Как будет оцениваться производительность агента?

Стратегия оценки должна быть определена до реализации. Без конкретных метрик итерация становится догадкой.

### Основные метрики:

**Уровень Успешности Задач (Task Success Rate - TSR)**

Уровень успешности задач измеряет, выполнил ли агент предполагаемую задачу корректно, а не просто функционировали ли отдельные компоненты. Это требует:

- Минимум 100 тестовых случаев для статистической значимости
- Распределение, соответствующее паттернам производственного трафика
- Краевые случаи, представляющие 10-15% датасета
- Версионный контроль для тестовых случаев с git
- Обзор и валидация доменными экспертами

Каждый тестовый случай должен определять:
- Входные данные и контекст
- Ожидаемый вывод или результат
- Функцию валидации для определения успеха
- Максимальную приемлемую задержку
- Максимальную приемлемую стоимость

**Построение набора данных для оценки:**

Структурируйте тестовые случаи для покрытия:
- Сценарии счастливого пути (50-60%)
- Общие вариации (25-30%)
- Краевые случаи (10-15%)
- Известные режимы отказа (5-10%)

Тестовые случаи должны быть выведены из:
- Производственных логов (реальные взаимодействия пользователей)
- Требований продукта (специфицированное поведение)
- Отчетов об ошибках (предыдущие сбои)
- Вклада доменных экспертов (ожидаемое поведение)

**Непрерывная оценка:**

Интегрируйте оценку в конвейер CI/CD:
- Запускайте полный набор тестов перед развертыванием
- Блокируйте развертывание, если TSR падает ниже порога
- Отслеживайте метрики со временем для обнаружения деградации
- Оповещайте о регрессии в любой категории метрик

Установите базовые линии:
- Минимальный приемлемый TSR (обычно >85% для производства)
- Максимальная приемлемая задержка P95
- Максимальная приемлемая стоимость на задачу
- Максимальный приемлемый уровень вмешательства человека

**Производственный мониторинг:**

Отслеживание в реальном времени:
- Уровень успеха в час/день
- Распределение задержки (P50, P95, P99)
- Стоимость на задачу и общие расходы
- Частота вмешательства человека
- Распределение типов ошибок
- Оценки удовлетворенности пользователей (когда доступно)

Настройте автоматические оповещения для:
- TSR падает ниже 80%
- Задержка P95 превышает SLA на 50%
- Почасовые затраты превышают бюджет на 30%
- Уровень ошибок увеличивается в 2 раза относительно базовой линии
- Уровень вмешательства человека превышает 20%

**Анализ корреляции метрик:**

Понимайте отношения между метриками:
- Коррелирует ли более высокая задержка с более низким TSR?
- Предсказывают ли определенные типы ошибок неудовлетворенность пользователей?
- Влияет ли время суток на производительность?
- Имеют ли конкретные сегменты пользователей разные уровни успеха?

---

## Вопрос 4: Каковы режимы отказа и стратегии смягчения?

Все системы терпят неудачу. Различие между производственным и экспериментальным кодом заключается в обработке сбоев.

### Сбои внешних зависимостей:

**Распространенные режимы отказа:**
- Превышены лимиты скорости API
- Таймауты сети или проблемы с подключением
- Простой сервиса или ухудшенная производительность
- Истечение аутентификации
- Изменения формата данных
- Несовместимости версий

**Стратегии смягчения:**

Реализуйте логику повторных попыток с экспоненциальным отступом:
- Начните с задержки 1-2 секунды
- Удвойте задержку после каждого сбоя
- Ограничьте максимальную задержку 30-60 секундами
- Ограничьте общее количество попыток 3-5

Используйте размыкатели цепей для предотвращения каскадных сбоев:
- Отслеживайте уровень сбоев во временном окне
- Откройте цепь после пороговых сбоев (например, 5 сбоев за 60 секунд)
- Позвольте цепи закрыться после периода восстановления
- Обеспечьте резервное поведение, когда цепь открыта

Реализуйте таймауты запросов:
- Установите агрессивные таймауты (2-5 секунд для большинства API)
- Терпите неудачу быстро, а не блокируйте бесконечно
- Логируйте случаи таймаута для мониторинга
- Рассматривайте таймаут как сбой для размыкателя цепи

### Сбои, специфичные для LLM:

**Смягчение галлюцинаций:**

Реализуйте многоуровневую валидацию:
- Валидация формата вывода (соответствие схеме)
- Валидация бизнес-правил (логическая согласованность)
- Проверка фактов против базы знаний
- Порогирование уверенности

Повторная попытка с усиленными промптами:
- Добавьте явные ограничения на основе сбоев валидации
- Включите примеры корректных выводов
- Подчеркните требования, которые были нарушены
- Ограничьте повторные попытки до 2-3 попыток

Используйте структурированные форматы вывода:
- Запрашивайте JSON с определенной схемой
- Валидируйте против моделей Pydantic или JSON Schema
- Отклоняйте некорректно сформированные ответы рано
- Предоставляйте примеры схем в промпте

**Обработка лимита скорости:**

Проактивно мониторьте использование API:
- Отслеживайте запросы в минуту/час
- Оповещайте при приближении к лимитам
- Реализуйте очередь запросов
- Масштабируйте уровень API перед достижением лимитов

При лимитировании скорости:
- Уважайте заголовки Retry-After
- Реализуйте экспоненциальный отступ
- Ставьте запросы в очередь для последующей обработки
- Рассмотрите возврат к альтернативным моделям

**Управление длиной контекста:**

Обрабатывайте переполнение контекста корректно:
- Мониторьте использование токенов на запрос
- Реализуйте разбиение на части для длинных документов
- Используйте суммаризацию для сжатия контекста
- Обеспечьте четкие сообщения об ошибках при превышении лимитов

### Сбои, специфичные для Tool/MCP:

**Ошибки вызова инструментов:**

LLM предоставляет недействительные параметры:
- Валидируйте параметры перед выполнением
- Верните четкое сообщение об ошибке LLM
- LLM повторяет попытку с исправленными параметрами
- Ограничьте попытки повтора для предотвращения циклов

Выполнение инструмента терпит неудачу:
- Перехватывайте исключения, возвращайте структурированную ошибку
- LLM получает ошибку и может попробовать альтернативу
- Логируйте сбои для мониторинга
- Размыкатель цепи для повторно падающих инструментов

Ошибки выбора инструмента:
- LLM выбирает неправильный инструмент для задачи
- Мониторьте точность выбора инструмента
- Улучшайте описания инструментов при обнаружении путаницы
- Добавляйте примеры, когда использовать каждый инструмент

**Сбои, специфичные для MCP:**

MCP сервер недоступен:
- Таймаут сети к MCP серверу
- Возврат к локальной реализации инструмента, если доступна
- Корректная деградация: информировать пользователя, предложить альтернативы
- Размыкатель цепи для каждого MCP сервера

Сбои обнаружения:
- Агент не может обнаружить доступные инструменты
- Кэшировать схемы инструментов локально
- Возврат к жестко закодированному списку инструментов
- Оповещать о проблемах сервиса обнаружения

Несоответствия версий:
- API MCP сервера изменился
- Агент использует устаревшую схему инструмента
- Согласование версий при подключении
- Поддерживать период обратной совместимости

### Мониторинг и оповещение:

**Реализация проверки здоровья:**

Определите метрики здоровья:
- Уровень ошибок (цель: <5%)
- Задержка P95 (определите на основе требований)
- Стоимость на задачу (мониторьте неожиданные увеличения)
- Уровень эскалации к человеку (цель: <20%)
- Уровень успеха инструмента (для каждого инструмента: >90%)
- Доступность MCP сервера (если используется: >99%)

Настройте панели мониторинга:
- Отображение метрик в реальном времени
- Исторические тренды
- Сравнение с базовой линией
- Возможности детализации

Настройте оповещения для:
- Критично: Уровень ошибок >10%, сервис недоступен, MCP серверы недоступны
- Предупреждение: Уровень ошибок >5%, увеличение стоимости >50%, увеличение сбоев инструментов
- Информация: Обнаружены необычные паттерны, снижение точности выбора инструментов

**Процедуры реагирования на инциденты:**

При обнаружении сбоя:
1. Определите затронутую область (пользователи, функции, временной период)
2. Оцените серьезность и влияние на бизнес
3. Реализуйте немедленное смягчение (откат, размыкатель цепи, отключение падающих инструментов)
4. Сообщите статус заинтересованным сторонам
5. Анализ первопричины после разрешения
6. Обновите руководства и мониторинг

---

## Вопрос 5: Где принимаются решения и как они объясняются?

Прозрачность решений критична для отладки, соответствия и доверия пользователей.

### Многоуровневая архитектура решений:

**Уровень 1: Жесткие Правила (fail-fast)**
- Проверки безопасности и соответствия
- Бюджетные и ресурсные ограничения
- Авторизация доступа к данным
- Регуляторные требования

Эти правила неоспоримы и выполняются перед любым рассуждением AI. Если жесткое правило терпит неудачу, запрос отклоняется немедленно без потребления ресурсов AI.

Примеры:
- Пользователь лишен необходимых разрешений → отклонить
- Запрос превышает бюджетный лимит → отклонить
- Необходимые данные недоступны → деградировать или отклонить
- Обнаружено нарушение соответствия → отклонить

**Уровень 2: Рассуждение AI (гибкое)**
- Классификация намерения
- Понимание контекста
- Планирование действий
- Выбор инструмента (если используется вызов инструментов)
- Генерация ответа

Этот уровень обрабатывает неоднозначность и требует суждения. AI принимает решения на основе паттернов, контекста и обучения, но эти решения должны быть валидированы перед выполнением.

Отслеживайте метаданные рассуждения:
- Используемая модель и версия
- Оценки уверенности
- Использование токенов
- Предпринятые шаги рассуждения
- Рассмотренные и выбранные инструменты
- Рассмотренные альтернативные действия

**Уровень 3: Валидация (страховочная сеть)**
- Проверки здравомыслия вывода
- Валидация бизнес-логики
- Безопасность и уместность
- Пороги уверенности
- Триггеры человек-в-цикле

Этот уровень предотвращает агента от предпринятия действий, которые проходят рассуждение AI, но нарушают практические ограничения или требования безопасности.

Проверки валидации:
- Корректность формата вывода
- Логическая согласованность
- Потенциальные негативные воздействия
- Обнаружение аномалий
- Требования порога уверенности
- Действительность результатов выполнения инструментов

### Трассировка решений:

**Всестороннее логирование:**

Для каждого решения захватывайте:
- Входные данные и контекст
- Решение, принятое на каждом уровне
- Рассуждение или правило, которое привело к решению
- Оценки уверенности
- Вызванные инструменты (параметры, результаты, задержка)
- Альтернативы, которые рассматривались, и почему отклонены
- Доказательства, поддерживающие решение
- Временная метка и путь выполнения

**Интерфейс объяснимости:**

Обеспечьте объяснения, понятные человеку:
- Какое решение было принято
- Почему это решение было выбрано
- Какая информация повлияла на решение
- Какие инструменты были использованы
- Какие альтернативы рассматривались
- Насколько уверена система
- Что должно измениться для другого решения

Структурируйте объяснения для разных аудиторий:
- Конечные пользователи: Простой, нетехнический язык
- Поддержка клиентов: Достаточно деталей для ответов на вопросы
- Разработчики: Полные технические детали и логи
- Аудиторы: Представление, ориентированное на соответствие

**Поддержка отладки:**

Позвольте разработчикам:
- Воспроизводить решения с теми же входными данными
- Изменять входные данные и наблюдать изменения решений
- Проходить через уровни решений
- Просматривать все рассмотренные альтернативы
- Отслеживать, почему сработали конкретные правила или логика
- Проверять вызовы инструментов и ответы
- Тестировать с различной доступностью инструментов

---

## Вопрос 6: Когда агент требует вмешательства человека?

Автономная работа должна быть сбалансирована с ограничениями безопасности и сложностью задачи.

### Триггеры вмешательства:

**Обязательные сценарии эскалации:**

Деструктивные действия:
- Удаление данных
- Модификации аккаунта
- Прекращение сервиса
- Необратимые операции

Финансовые воздействия:
- Транзакции выше порога (например, $1,000)
- Возвраты или кредиты
- Изменения подписки
- Распределение бюджета

Пороги уверенности:
- Уверенность AI ниже 75-80%
- Противоречивая информация
- Неоднозначное намерение пользователя
- Новые ситуации вне обучения
- Неопределенность выбора инструмента

Обнаружение аномалий:
- Необычное поведение для пользователя
- Действия, несогласующиеся с историей
- Паттерны, предполагающие мошенничество или злоупотребление
- Запросы вне нормальных параметров

Чувствительные контексты:
- Злые или расстроенные пользователи
- Юридические или регуляторные последствия
- Проблемы безопасности
- Запросы, связанные с конфиденциальностью

Новые пользователи:
- Ограниченные исторические данные
- Более высокий риск неправильного понимания
- Возможность построения отношений
- Обучение паттернам для будущего

Сбои Tool/MCP:
- Множественные сбои выполнения инструментов
- MCP сервер недоступен для критического инструмента
- Невозможность завершить задачу из-за проблем с инструментами

**Уровни срочности эскалации:**

Немедленно (< 5 минут):
- VIP клиенты
- Серьезные проблемы
- Риск дохода
- Потенциальное воздействие на PR

Высокий (< 1 часа):
- Затронуты множественные пользователи
- Ухудшенный сервис
- Повторяющиеся сбои
- Нарастающая неудовлетворенность

Нормальный (< 24 часов):
- Один пользователь, несрочно
- Необходимо уточнение
- Краевые случаи
- Возможности для улучшения

### Постепенное внедрение автономности:

**Фаза 1: Теневой Режим (Неделя 1-2)**

Агент работает, но не выполняет действия:
- Логирует предлагаемые действия
- Человек выполняет задачи вручную
- Сравнивайте предложения агента с решениями человека
- Измеряйте уровень согласия

Критерии успеха:
- >95% согласие с решениями человека
- Нет серьезных ошибок в предложениях
- Задержка в приемлемом диапазоне
- Доверие команды к рассуждению агента
- Точность выбора инструментов >90%

**Фаза 2: Требуется Одобрение (Неделя 3-4)**

Агент предлагает, человек одобряет:
- Агент генерирует планы действий
- Человек проверяет перед выполнением
- Отслеживайте уровни одобрения/отклонения
- Анализируйте причины отклонения

Критерии успеха:
- >90% уровень одобрения
- Низкая частота модификаций
- Быстрый процесс одобрения (< 2 минуты)
- Улучшающиеся тренды точности

**Фаза 3: Контролируемая Автономность (Месяц 2)**

Агент обрабатывает низкорисковые задачи автономно:
- Автоматически выполняет простые случаи
- Запрашивает одобрение для сложных/высокорисковых
- Мониторит все действия
- Готовые процедуры отката

Критерии успеха:
- Уровень ошибок < 2%
- Уровень эскалации < 15%
- Удовлетворенность пользователей поддерживается
- Стоимость в рамках прогнозов

**Фаза 4: Полная Автономность (Месяц 3+)**

Агент работает независимо:
- Обрабатывает большинство случаев автоматически
- Эскалирует только краевые случаи
- Всестороннее логирование аудита
- Непрерывный мониторинг

Поддерживайте:
- Еженедельные сессии обзора
- Анализ ошибок
- Интеграция обратной связи пользователей
- Оптимизация производительности

---

## Вопрос 7: Какова стратегия поддержки и эволюции?

### Вызовы поддержки, специфичные для агентов:

**Дрейф промптов:**
- Поведение модели меняется со временем даже с тем же промптом
- Провайдеры обновляют модели без уведомления о версии (GPT-3.5, GPT-4, Claude)
- Ранее работающие промпты могут деградировать
- Стратегия: Непрерывная оценка против тестового набора, обнаружение регрессии производительности

**Эволюция модели эмбеддингов:**
- Переключение моделей эмбеддингов инвалидирует vector DB
- Требует полной переиндексации всех документов
- Стоимость и время для переэмбеддинга больших корпусов
- Стратегия: Версионные индексы, A/B тест новых эмбеддингов перед миграцией

**Изменения схемы вызова инструментов/функций:**
- Модели улучшают вызов инструментов со временем — или деградируют
- Добавление новых инструментов может сбить с толку выбор инструмента агента
- Описания функций критически влияют на поведение агента
- Стратегия: Регрессионное тестирование точности вызова инструментов, версионирование определений инструментов

**Эволюция протокола MCP:**
- Стандарт MCP развивается (все еще рано в 2025)
- Реализации сервера могут иметь несовместимости версий
- Разрывающие изменения в обновлениях протокола
- Стратегия: Закрепить версию протокола MCP, тщательно тестировать обновления

**Согласованность поведения агента:**
- Недетерминировано: одинаковые входные данные могут производить разные выводы
- Настройки температуры влияют на воспроизводимость
- Обновления модели изменяют поведение молча
- Стратегия: Снимки версий модели, использовать фиксированные семена в тестировании, логировать все решения

**Устаревание базы знаний:**
- Документы в vector DB становятся устаревшими
- Агент предоставляет некорректную информацию из старых источников
- Нет автоматического уведомления, когда исходный материал меняется
- Стратегия: Версионирование документов, запланированная переиндексация, отслеживание свежести источников

**Дрейф координации мультиагентов:**
- Отдельные агенты обновляются независимо
- Протоколы координации могут сломаться
- Эмерджентное поведение от изменений взаимодействия
- Стратегия: Интеграционное тестирование через команду агентов, версионная блокировка координирующих агентов

**Изменения доступности инструментов:**
- API, от которых вы зависите, устаревают
- Сторонние MCP серверы идут в офлайн
- Реализации инструментов ломаются из-за внешних изменений
- Стратегия: Мониторить здоровье инструментов, поддерживать резервные варианты, абстрагировать интерфейсы инструментов

### Соображения, специфичные для фреймворка:

**Быстрая эволюция LangChain/LangGraph:**
- Разрывающие изменения API в минорных версиях обычны
- Примеры сообщества становятся устаревшими быстро
- Руководства по миграции часто отстают от релизов
- Стратегия: Закрепить точные версии в производстве, поддерживать внутреннюю документацию, бюджетировать квартальные циклы обновлений

**Изменения формата индекса LlamaIndex:**
- Формат хранения индекса может измениться между версиями
- Скрипты миграции не всегда предоставляются
- Риск: Сохраненные индексы становятся нечитаемыми
- Стратегия: Тестирование экспорта/импорта, поддерживать возможность пересборки индекса

**Незрелость экосистемы MCP:**
- Стандарт все еще развивается, ожидайте разрывающих изменений
- Доступность сервера не гарантирована
- Мало производственно протестированных реализаций
- Стратегия: Построить уровень абстракции над MCP, поддерживать не-MCP резервные варианты

**Устаревание инструмента/интеграции:**
- Сторонние интеграции ломаются при изменении API
- Фреймворк может прекратить поддержку инструментов, от которых вы зависите
- MCP серверы могут быть брошены мейнтейнерами
- Стратегия: Абстрагировать реализации инструментов, владеть уровнем интеграции, мониторить здоровье экосистемы

### Мониторинг, специфичный для агентов:

**Регрессия поведения агента:**
- Отслеживать: Точность выбора инструмента со временем
- Отслеживать: Среднее количество шагов до завершения задачи
- Отслеживать: Уровень успеха восстановления после ошибок
- Отслеживать: Тренды частоты вмешательства человека
- Оповещать: Любая метрика деградирует >10% неделя к неделе

**Дрейф качества поиска:**
- Отслеживать: Точность/полнота поиска на фиксированном тестовом наборе
- Отслеживать: Средние оценки релевантности для извлеченных чанков
- Отслеживать: Обратная связь пользователей о качестве ответов
- Оповещать: Метрики поиска падают ниже базовой линии

**Деградация производительности инструментов:**
- Отслеживать: Уровень успеха для каждого инструмента
- Отслеживать: Задержка на вызов инструмента
- Отслеживать: Типы ошибок для каждого инструмента
- Оповещать: Уровень успеха инструмента падает ниже 90%

**Мониторинг здоровья MCP:**
- Отслеживать: Доступность MCP сервера
- Отслеживать: Время отклика для каждого MCP сервера
- Отслеживать: Проблемы совместимости версий
- Оповещать: Простой сервера, всплески задержки, конфликты версий

**Аномалии стоимости:**
- Отслеживать: Использование токенов на тип задачи
- Отслеживать: Затраты на эмбеддинги на пакет документов
- Отслеживать: Затраты на запросы Vector DB
- Отслеживать: Использование MCP сервера, если платное
- Оповещать: Любое увеличение затрат >30% без увеличения использования

**Обнаружение цикла агента:**
- Мониторить: Агент застревает в повторяющихся действиях
- Мониторить: Частота таймаута для задач агента
- Мониторить: Максимальное количество шагов достигнуто без завершения
- Мониторить: Один и тот же инструмент вызван повторно без прогресса
- Оповещать: Обнаружены паттерны циклов, реализовать размыкатели цепей

### Стратегии версионирования:

**Развертывание мультиверсий:**
- Запускать старую и новую версии агента параллельно
- Маршрутизировать трафик на основе сегмента пользователя или A/B теста
- Сравнивать метрики между версиями в производстве
- Немедленный откат, если новая версия деградирует

**Версионирование промптов с оценкой:**
- Хранить промпты в версионном контроле
- Тегировать производственные версии
- Запускать набор оценки на все изменения промптов
- Требовать одобрения на основе результатов оценки перед развертыванием

**Версионирование определений инструментов:**
- Версионный контроль всех схем инструментов
- Отслеживать, какая версия агента использует какие определения инструментов
- A/B тестировать изменения описаний инструментов
- Откатывать определения инструментов независимо от кода

**Версионирование индексов:**
- Поддерживать множественные индексы vector DB
- Маршрутизировать запросы к конкретным версиям индекса
- Тестировать новые индексы с подмножеством трафика
- Переключаться, когда метрики доказывают превосходство

**Версионирование MCP сервера:**
- Развертывать множественные версии MCP серверов
- Маршрутизировать агентов к совместимым версиям серверов
- Постепенная миграция через версии серверов
- Поддерживать период обратной совместимости

**Конфигурация агента как код:**
- Версионный контроль: Выбор модели, температура, доступные инструменты, MCP серверы
- Позволить откат конфигурации отдельно от кода
- A/B тест изменений конфигурации
- Отслеживать, какая версия конфигурации произвела какой результат

---

![Сравнение Архитектуры](/images/posts/ai-agent-comparison.png)

## Чеклист Реализации

Перед развертыванием ИИ-агента в производство, проверьте:

### Архитектура
- [ ] Выбран и обоснован подходящий уровень сложности
- [ ] Выбор фреймворка (LangChain/LangGraph/LlamaIndex) документирован с обоснованием
- [ ] Паттерны доступа к данным документированы и протестированы
- [ ] Обоснованы типы хранилища (vector/RDBMS/graph/KV)
- [ ] Решен подход интеграции инструментов (прямой/вызов инструментов/MCP) с обоснованием
- [ ] Реализованы стратегии резервирования для всех зависимостей
- [ ] Рассчитаны прогнозы стоимости для ожидаемой нагрузки
- [ ] Документировано решение: n8n vs фреймворк агентов с конкретным обоснованием

### Оценка
- [ ] Создан тестовый датасет с 100+ случаями
- [ ] Определены и измеримы метрики успеха
- [ ] Непрерывная оценка интегрирована в CI/CD
- [ ] Настроены панели производственного мониторинга
- [ ] Установлены базовые метрики
- [ ] Определены пороги оповещения
- [ ] Метрики качества поиска, если используется RAG

### Надежность
- [ ] Все вызовы внешних API имеют логику таймаута и повтора
- [ ] Реализованы размыкатели цепей для критических зависимостей
- [ ] Обработка ошибок выполнения инструментов
- [ ] Стратегия резервирования MCP сервера (если применимо)
- [ ] Обработка ошибок покрывает все идентифицированные режимы отказа
- [ ] Определена стратегия корректной деградации
- [ ] Реализована обработка лимита скорости
- [ ] Определена обработка переполнения контекста

### Наблюдаемость
- [ ] Реализовано структурированное логирование
- [ ] Трассировки решений захвачены для отладки
- [ ] Логирование вызовов инструментов (параметры, результаты, задержка)
- [ ] Логирование взаимодействий MCP (если применимо)
- [ ] Настроены оповещения для аномалий
- [ ] Логи аудита для всех действий
- [ ] Отслеживаются метрики производительности
- [ ] Автоматизировано отслеживание затрат

### Безопасность
- [ ] Определена политика вмешательства человека
- [ ] Документирован план постепенного внедрения
- [ ] Реализованы пути эскалации
- [ ] Протестирована процедура отката
- [ ] Завершен обзор безопасности
- [ ] Проверены требования соответствия
- [ ] Определены контроли доступа к инструментам
- [ ] Настроена аутентификация MCP сервера (если применимо)

### Поддержка
- [ ] Зависимости закреплены с диапазонами версий
- [ ] Версии промптов отслеживаются в коде
- [ ] Версионированы определения инструментов
- [ ] Настроена цепочка резервирования модели
- [ ] Закреплена версия протокола MCP (если применимо)
- [ ] Автоматизирован мониторинг затрат
- [ ] Определено расписание обновлений
- [ ] Документация полная
- [ ] Мониторинг регрессии поведения агента
- [ ] Стратегия обновления базы знаний

---

## Заключение

Эти семь вопросов формируют техническую структуру для разработки ИИ-агентов, которая рассматривает общие режимы отказа в производстве. Структура приоритизирует надежность, наблюдаемость и поддерживаемость над начальной скоростью разработки.

Каждый вопрос нацелен на конкретные инженерные вызовы:
1. Архитектура данных и качество (типы хранилища, паттерны поиска, свежесть)
2. Подходящая техническая сложность (включая когда избегать переинженерии с фреймворками агентов)
2.5. Стратегия доступа к внешним системам (прямые вызовы API vs вызов инструментов vs MCP)
3. Объективное измерение производительности
4. Систематическая обработка сбоев (включая сбои, специфичные для инструментов/MCP)
5. Прозрачность решений
6. Стратегия человеческого надзора
7. Долгосрочное планирование поддержки (включая дрейф и эволюцию, специфичные для агентов)

Реализация этой структуры снижает производственные инциденты, улучшает эффективность отладки и обеспечивает четкие метрики для итерации. Выбор между инструментами автоматизации рабочих процессов (n8n), различными фреймворками агентов (LangChain, LangGraph, LlamaIndex), прямым контролем API, абстракциями вызова инструментов или MCP должен быть обусловлен требованиями задачи и операционной зрелостью, а не технологическими предпочтениями или циклами хайпа.

---

*Строите производственных ИИ-агентов в OverX? [Свяжитесь с нашей командой](https://overx.ai/contact) для архитектурного обзора и поддержки реализации.*
